(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{420:function(v,_,a){"use strict";a.r(_);var t=a(2),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"html语义化的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#html语义化的理解"}},[v._v("#")]),v._v(" html语义化的理解")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("代码结构: 使页面在没有css的情况下,也能够呈现出好的内容结构")])]),v._v(" "),_("li",[_("p",[_("a",[v._v("有利于SEO:")]),v._v(" 爬虫根据标签来分配关键字的权重,因此可以和搜索引擎建立良好的沟通,帮助爬虫抓取更多的有效信息")])]),v._v(" "),_("li",[_("p",[_("a",[v._v("方便其他设备解析：")]),v._v(" 如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染页面")])]),v._v(" "),_("li",[_("p",[_("a",[v._v("便于团体的开发和维护:")]),v._v(" 语义化使代码更具有可读性，让其他开发人员更加理解你的html结构，减少差异化。遵循 W3C 标准的团队都遵循这个标准。")])])]),v._v(" "),_("p",[v._v("常用的语义元素有："),_("a",[v._v("header、nav、main、footer、article、section、aside")])]),v._v(" "),_("h2",{attrs:{id:"iframe"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#iframe"}},[v._v("#")]),v._v(" iframe")]),v._v(" "),_("p",[_("a",[v._v("iframe称之为嵌入式框架")]),v._v(" 嵌入式框架可以把完整的网页内容嵌入到现有的网页中。")]),v._v(" "),_("h1",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("ul",[_("li",[v._v("重载页面时不需要重载整个页面只需要重载页面中的一个框架页")]),v._v(" "),_("li",[v._v("可以使脚本、可以并行下载")]),v._v(" "),_("li",[v._v("可以实现跨子域通信")])]),v._v(" "),_("h1",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("ul",[_("li",[v._v("会产生很多页面，不容易管理")]),v._v(" "),_("li",[v._v("调用外部页面，需要额外调用 CSS，给页面带来额外的请求次数")]),v._v(" "),_("li",[v._v("iframe 会阻塞主页面的 onload 事件")]),v._v(" "),_("li",[v._v("浏览器的后退按钮无效")]),v._v(" "),_("li",[v._v("无法被一些搜索引擎索引识别")]),v._v(" "),_("li",[v._v("多数小型的移动设备无法完全显示框架")])]),v._v(" "),_("h2",{attrs:{id:"bom和dom分别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bom和dom分别是什么"}},[v._v("#")]),v._v(" BOM和DOM分别是什么")]),v._v(" "),_("p",[_("a",[v._v("BOM是浏览器对象模型")]),v._v(" 用来获取或设置浏览器的属性、行为。例如：新建窗口、获取屏幕分辨率、浏览器版本号等")]),v._v(" "),_("p",[_("a",[v._v("DOM是文档对象模型：")]),v._v(" 用来获取或设置文档中标签的属性、例如获取或者设置input表单的value值")]),v._v(" "),_("h2",{attrs:{id:"css盒模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css盒模型"}},[v._v("#")]),v._v(" CSS盒模型")]),v._v(" "),_("p",[v._v("盒模型都是由四个部分组成的，分别是"),_("a",[v._v(" margin、border、padding和content")])]),v._v(" "),_("p",[v._v("标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("标准盒模型的width和height属性的范围只包含了content，")])]),v._v(" "),_("li",[_("p",[v._v("IE盒模型的width和height属性的范围包含了border、padding和content。")])])]),v._v(" "),_("p",[v._v("可以通过修改元素的box-sizing属性来改变元素的盒模型：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("box-sizing: content-box")]),v._v("表示标准盒模型（默认值）")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("box-sizing: border-box")]),v._v("表示IE盒模型（怪异盒模型）")])])]),v._v(" "),_("h2",{attrs:{id:"怎么让一个-div-水平垂直居中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么让一个-div-水平垂直居中"}},[v._v("#")]),v._v(" 怎么让一个 div 水平垂直居中")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("通过绝对定位实现垂直居中")])]),v._v(" "),_("li",[_("p",[v._v("通过 "),_("a",[v._v("transform")]),v._v(" 实现垂直居中")])]),v._v(" "),_("li",[_("p",[v._v("使用弹性盒子居中")])])]),v._v(" "),_("h2",{attrs:{id:"bfc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bfc"}},[v._v("#")]),v._v(" BFC")]),v._v(" "),_("p",[v._v("所谓 BFC，指的是一个独立的布局环境，BFC 内部的元素布局与外部互不影响。")]),v._v(" "),_("h1",{attrs:{id:"触发-bfc-的方式有很多-常见的有"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#触发-bfc-的方式有很多-常见的有"}},[v._v("#")]),v._v(" 触发 BFC 的方式有很多，常见的有：")]),v._v(" "),_("ul",[_("li",[v._v("设置浮动")]),v._v(" "),_("li",[v._v("overflow 设置为 auto、scroll、hidden")]),v._v(" "),_("li",[v._v("positon 设置为 absolute、fixed")])]),v._v(" "),_("h1",{attrs:{id:"常见bfc的应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见bfc的应用"}},[v._v("#")]),v._v(" 常见BFC的应用")]),v._v(" "),_("ul",[_("li",[v._v("解决浮动元素令父元素高度坍塌的问题")]),v._v(" "),_("li",[v._v("解决非浮动元素被浮动元素覆盖问题")]),v._v(" "),_("li",[v._v("解决外边距垂直方向重合问题")])]),v._v(" "),_("h2",{attrs:{id:"js-的基本数据类型有哪些-基本数据类型和引用数据类型的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js-的基本数据类型有哪些-基本数据类型和引用数据类型的区别"}},[v._v("#")]),v._v(" JS 的基本数据类型有哪些？基本数据类型和引用数据类型的区别")]),v._v(" "),_("h1",{attrs:{id:"基本数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[v._v("#")]),v._v(" 基本数据类型")]),v._v(" "),_("p",[v._v("JavaScript共有八种数据类型，分别是 "),_("a",[v._v("Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt")])]),v._v(" "),_("p",[v._v("这些数据可以分为原始数据类型和引用数据类型：")]),v._v(" "),_("ul",[_("li",[v._v("栈：原始数据类型（Undefined、Null、Boolean、Number、String）")]),v._v(" "),_("li",[v._v("堆：引用数据类型（对象、数组和函数）")])]),v._v(" "),_("h1",{attrs:{id:"基本数据类型和引用数据类型的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型和引用数据类型的区别"}},[v._v("#")]),v._v(" 基本数据类型和引用数据类型的区别")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("访问方式:")])]),v._v(" "),_("li",[_("p",[v._v("原始值：访问到的是值")])]),v._v(" "),_("li",[_("p",[v._v("引用值：访问到的是引用地址 ("),_("code",[v._v("js不允许直接访问保存在堆中的对象、首先得到在堆中的地- 址，然后按照这个地址去获得对象的值")]),v._v(")")])]),v._v(" "),_("li",[_("p",[v._v("比较方式:")]),v._v(" "),_("ul",[_("li",[v._v("原始值：比较的是值")]),v._v(" "),_("li",[v._v("引用值: 比较的是引用的地址")])])]),v._v(" "),_("li",[_("p",[v._v("变量赋值:")]),v._v(" "),_("ul",[_("li",[v._v("原始值赋值：赋值的是新值，与原来互不影响")]),v._v(" "),_("li",[v._v("引用值赋值：赋值的是地址，指向原值所在堆内存中的地址")])])]),v._v(" "),_("li",[_("p",[v._v("动态属性:")]),v._v(" "),_("ul",[_("li",[v._v("原始值：赋值的是值")]),v._v(" "),_("li",[v._v("引用值：赋值的是地址")])])])]),v._v(" "),_("h2",{attrs:{id:"js数据类型检测的方式有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js数据类型检测的方式有哪些"}},[v._v("#")]),v._v(" Js数据类型检测的方式有哪些")]),v._v(" "),_("ul",[_("li",[_("p",[_("a",[v._v("typeof")])]),v._v(" "),_("ul",[_("li",[v._v("其中数组、对象、null都会被判断为object，其他判断都正确")]),v._v(" "),_("li",[v._v("typeof返回的类型都是字符串形式")])])]),v._v(" "),_("li",[_("p",[_("a",[v._v("instanceof")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("instanceof")]),v._v("可以正确判断对象的类型，"),_("a",[v._v("其内部运行机制是判断在其原型链中能否找到该类型的原型")])])])]),v._v(" "),_("li",[_("p",[_("a",[v._v("constructor")])])]),v._v(" "),_("li",[_("p",[_("a",[v._v("Object.prototype.toString.call()")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Object.prototype.toString.call()")]),v._v(" 使用 Object 对象的原型方法 toString 来判断数据类型：")])])])]),v._v(" "),_("h2",{attrs:{id:"es6-新增哪些东西"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es6-新增哪些东西"}},[v._v("#")]),v._v(" ES6 新增哪些东西")]),v._v(" "),_("ol",[_("li",[v._v("箭头函数")]),v._v(" "),_("li",[v._v("字符串模板")]),v._v(" "),_("li",[v._v("支持模块化（import、export）")]),v._v(" "),_("li",[v._v("类（class、constructor、extends）")]),v._v(" "),_("li",[v._v("let、const 关键字")]),v._v(" "),_("li",[v._v("新增一些数组、字符串等内置构造函数方法，例如 Array.from、Array.of 、Math.sign、Math.trunc 等")]),v._v(" "),_("li",[v._v("新增一些语法，例如扩展操作符、解构、函数默认参数等")]),v._v(" "),_("li",[v._v("新增一种基本数据类型 Symbol")]),v._v(" "),_("li",[v._v("新增元编程相关，例如 proxy、Reflect")]),v._v(" "),_("li",[v._v("Set 和 Map 数据结构")]),v._v(" "),_("li",[v._v("Promise")]),v._v(" "),_("li",[v._v("Generator 生成器")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("暂时性死区：使用 let / const 命令声明变量之前，该变量都是不可用的\n")])])]),_("h2",{attrs:{id:"箭头函数与普通函数的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与普通函数的区别"}},[v._v("#")]),v._v(" 箭头函数与普通函数的区别")]),v._v(" "),_("ol",[_("li",[v._v("箭头函数没有自己的this、会捕获其所在的上下文的this值，作为自己的this值")]),v._v(" "),_("li",[v._v("箭头函数继承来的this指向永远不会改变")]),v._v(" "),_("li",[v._v("call()、apply()、bind()等方法不能改变箭头函数中this的指向")]),v._v(" "),_("li",[v._v("箭头函数是匿名函数，不能作为构造函数，不能使用new")]),v._v(" "),_("li",[v._v("箭头函数没有自己的arguments")]),v._v(" "),_("li",[v._v("箭头函数没有prototype（原型）")]),v._v(" "),_("li",[v._v("箭头函数不能用作Generator函数，不能使用yeild关键字")])]),v._v(" "),_("h2",{attrs:{id:"bind-apply-call三者的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bind-apply-call三者的区别"}},[v._v("#")]),v._v(" bind，apply，call三者的区别")]),v._v(" "),_("ol",[_("li",[v._v("三者都可以改变函数的"),_("code",[v._v("this")]),v._v("对象指向")]),v._v(" "),_("li",[v._v("三者第一个参数都是"),_("code",[v._v("this")]),v._v("要指向的对象，如果如果没有这个参数或参数为"),_("code",[v._v("undefined")]),v._v("或"),_("code",[v._v("null")]),v._v("，则默认指向全局"),_("code",[v._v("window")])]),v._v(" "),_("li",[v._v("三者都可以传参，但是"),_("code",[v._v("apply")]),v._v("是数组，而"),_("code",[v._v("call")]),v._v("是参数列表，且"),_("code",[v._v("apply")]),v._v("和"),_("code",[v._v("call")]),v._v("是一次性传入参数，而"),_("code",[v._v("bind")]),v._v("可以分为多次传入")]),v._v(" "),_("li",[v._v("bind是返回绑定this之后的函数，"),_("code",[v._v("apply")]),v._v("、"),_("code",[v._v("call")]),v._v(" 则是立即执行")])]),v._v(" "),_("h2",{attrs:{id:"是否了解-javascript-中的包装类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#是否了解-javascript-中的包装类型"}},[v._v("#")]),v._v(" 是否了解 JavaScript 中的包装类型？")]),v._v(" "),_("p",[v._v("包装对象 : 就是当基本类型以对象的方式去使用时，JavaScript 会转换成对应的包装类型，相当于 "),_("a",[v._v("new")]),v._v(" 一个对象，内容和基本类型的内容一样，然后当操作完成再去访问的时候，这个临时对象会被销毁，然后再访问时候就是 "),_("a",[v._v("undefined")])]),v._v(" "),_("p",[_("a",[v._v("代码理解:")])]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("var str = 'hello';\nstr.number = 10; //假设我们想给字符串添加一个属性 number ，后台会有如下步骤\n(\n    var _str = new String('hello'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象\n    _str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存\n    _str =null; // 3 这个对象又被销毁\n)\nconsole.log(str.number); // undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤\n(\n   var str = new String('hello');// 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为 hello 对象\n   str.number = undefined;// 2 因为包装对象下面没有 number 这个属性，所以又会重新添加，因为没有值，所以值是未定义;然后弹出结果\n   str =null; // 3 这个对象又被销毁\n)\n")])])]),_("h2",{attrs:{id:"闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[v._v("#")]),v._v(" 闭包")]),v._v(" "),_("p",[_("a",[v._v("闭包是指有权访问另一个函数作用域中的变量的函数")]),v._v(" ———— 《JavaScript高级程序设计》")]),v._v(" "),_("ul",[_("li",[v._v("闭包用途：")])]),v._v(" "),_("ol",[_("li",[v._v("能够访问函数定义时所在的词法作用域（阻止其被回收）")]),v._v(" "),_("li",[v._v("私有变量化")]),v._v(" "),_("li",[v._v("模拟块级作用域")]),v._v(" "),_("li",[v._v("创建模块")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("闭包缺点：闭包调用函数的变量，并且这个变量在函数执行完之后，不能释放，会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏。")])]),v._v(" "),_("li",[_("p",[v._v("解决：变量设置成null")])])]),v._v(" "),_("h2",{attrs:{id:"原型和原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[v._v("#")]),v._v(" 原型和原型链")]),v._v(" "),_("h1",{attrs:{id:"原型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[v._v("#")]),v._v(" 原型")]),v._v(" "),_("ol",[_("li",[v._v("每个实例对象都有一个 "),_("a",[v._v("proto")]),v._v(" 属性，该属性指向自己的原型对象")]),v._v(" "),_("li",[v._v("每个构造函数都有一个 prototype 属性，该属性指向实例对象的原型对象")]),v._v(" "),_("li",[v._v("原型对象里的 constructor 指向构造函数本身")])]),v._v(" "),_("h1",{attrs:{id:"原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[v._v("#")]),v._v(" 原型链")]),v._v(" "),_("p",[v._v("当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾null\n"),_("img",{staticStyle:{zoom:"100%"},attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffb1e07e1c124392bdf96c97975143ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"}})]),v._v(" "),_("h2",{attrs:{id:"作用域和作用域链的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域和作用域链的理解"}},[v._v("#")]),v._v(" 作用域和作用域链的理解")]),v._v(" "),_("h1",{attrs:{id:"作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[v._v("#")]),v._v(" 作用域")]),v._v(" "),_("p",[v._v("（1）全局作用域")]),v._v(" "),_("ul",[_("li",[v._v("最外层函数和最外层函数外面定义的变量拥有全局作用域")]),v._v(" "),_("li",[v._v("所有未定义直接赋值的变量自动声明为全局作用域")]),v._v(" "),_("li",[v._v("所有window对象的属性拥有全局作用域")]),v._v(" "),_("li",[v._v("全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。")])]),v._v(" "),_("p",[v._v("（2）函数作用域")]),v._v(" "),_("ul",[_("li",[v._v("函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到")]),v._v(" "),_("li",[v._v("作用域是分层的，内层作用域可以访问外层作用域，反之不行")])]),v._v(" "),_("p",[v._v("（3）块级作用域")]),v._v(" "),_("ul",[_("li",[v._v("使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）")]),v._v(" "),_("li",[v._v("let和const声明的变量不会有变量提升，也不可以重复声明")]),v._v(" "),_("li",[v._v("在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。")])]),v._v(" "),_("h1",{attrs:{id:"作用域链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[v._v("#")]),v._v(" 作用域链")]),v._v(" "),_("p",[v._v("在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是"),_("a",[v._v("自由变量")]),v._v("。\n如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是"),_("a",[v._v("作用域链")])]),v._v(" "),_("p",[v._v("作用域链有一个非常重要的特性，"),_("a",[v._v("那就是作用域中的值是在函数创建的时候，就已经被存储了，是静态的")])]),v._v(" "),_("h2",{attrs:{id:"宏任务和微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[v._v("#")]),v._v(" 宏任务和微任务")]),v._v(" "),_("ul",[_("li",[v._v("常见的宏任务有：setTimeout、setInterval、requestAnimationFrame、script等。")]),v._v(" "),_("li",[v._v("常见的微任务有：new Promise( ).then(回调)、MutationObserver 等。")])]),v._v(" "),_("h1",{attrs:{id:"宏任务和微任务的执行流程-总结起来就是"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务的执行流程-总结起来就是"}},[v._v("#")]),v._v(" 宏任务和微任务的执行流程，总结起来就是：")]),v._v(" "),_("p",[_("a",[v._v("js在调用时，优先取出微任务，并且在执行过程中如果创建了新的作业，则放在本次执行完后紧接着调用，微任务执行完成后，再取出宏任务执行")])]),v._v(" "),_("h2",{attrs:{id:"哪些情况会导致内存泄漏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哪些情况会导致内存泄漏"}},[v._v("#")]),v._v(" 哪些情况会导致内存泄漏")]),v._v(" "),_("p",[v._v("以下四种情况会造成内存的泄漏：")]),v._v(" "),_("ul",[_("li",[_("a",[v._v("意外的全局变量：")]),v._v(" 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。")]),v._v(" "),_("li",[_("a",[v._v("被遗忘的计时器或回调函数：")]),v._v("  设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。")]),v._v(" "),_("li",[_("a",[v._v("脱离 DOM 的引用：")]),v._v("  获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。")]),v._v(" "),_("li",[_("a",[v._v("闭包：")]),v._v("  不合理的使用闭包，从而导致某些变量一直被留在内存当中")])]),v._v(" "),_("h2",{attrs:{id:"请介绍一下-javascript-中的垃圾回收站机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#请介绍一下-javascript-中的垃圾回收站机制"}},[v._v("#")]),v._v(" 请介绍一下 JavaScript 中的垃圾回收站机制")]),v._v(" "),_("p",[v._v("JavaScript 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。\nJavaScript 常见的垃圾回收方式："),_("a",[v._v("标记清除、引用计数")]),v._v("方式。")]),v._v(" "),_("h1",{attrs:{id:"标记清除方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记清除方式"}},[v._v("#")]),v._v(" 标记清除方式：")]),v._v(" "),_("ul",[_("li",[v._v("工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。")]),v._v(" "),_("li",[v._v("工作流程：")]),v._v(" "),_("li",[v._v("垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；")]),v._v(" "),_("li",[v._v("去掉环境中的变量以及被环境中的变量引用的变量的标记；")]),v._v(" "),_("li",[v._v("被加上标记的会被视为准备删除的变量；")]),v._v(" "),_("li",[v._v("垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。")])]),v._v(" "),_("h1",{attrs:{id:"引用计数方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用计数方式"}},[v._v("#")]),v._v(" 引用计数方式：")]),v._v(" "),_("ul",[_("li",[v._v("工作原理：跟踪记录每个值被引用的次数。")]),v._v(" "),_("li",[v._v("工作流程：")]),v._v(" "),_("li",[v._v("声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是 1；")]),v._v(" "),_("li",[v._v("同一个值又被赋值给另一个变量，这个引用类型值的引用次数加 1；")]),v._v(" "),_("li",[v._v("当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减 1；")]),v._v(" "),_("li",[v._v("当引用次数变成 0 时，说明没办法访问这个值了；")]),v._v(" "),_("li",[v._v("当垃圾收集器下一次运行时，它就会释放引用次数是 0 的值所占的内存")])]),v._v(" "),_("h2",{attrs:{id:"防抖-节流是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#防抖-节流是什么"}},[v._v("#")]),v._v(" 防抖，节流是什么")]),v._v(" "),_("ul",[_("li",[_("a",[v._v("函数防抖(debounce)")]),v._v("，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行")]),v._v(" "),_("li",[_("a",[v._v("函数节流(throttle)")]),v._v("，指连续触发事件但是在 n 秒中只执行一次函数。即 2n 秒内执行 2 次...")])]),v._v(" "),_("h2",{attrs:{id:"深拷贝和浅拷贝"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[v._v("#")]),v._v(" 深拷贝和浅拷贝")]),v._v(" "),_("ul",[_("li",[_("p",[_("a",[v._v("浅拷贝")]),v._v("：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）\n浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。")])]),v._v(" "),_("li",[_("p",[_("a",[v._v("深拷贝")]),v._v("：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。")])])]),v._v(" "),_("h2",{attrs:{id:"事件冒泡和事件捕获"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡和事件捕获"}},[v._v("#")]),v._v(" 事件冒泡和事件捕获")]),v._v(" "),_("h1",{attrs:{id:"事件冒泡"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡"}},[v._v("#")]),v._v(" 事件冒泡")]),v._v(" "),_("p",[v._v("微软提出了名为"),_("a",[v._v("事件冒泡")]),v._v("(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("p -> div -> body -> html -> document \n")])])]),_("h1",{attrs:{id:"事件捕获"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件捕获"}},[v._v("#")]),v._v(" 事件捕获")]),v._v(" "),_("p",[v._v("网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("document -> html -> body -> div -> p \n")])])]),_("h2",{attrs:{id:"http和https区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http和https区别"}},[v._v("#")]),v._v(" Http和Https区别")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("HTTP")]),v._v(" 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头")]),v._v(" "),_("li",[_("code",[v._v("HTTP")]),v._v(" 是不安全的，而 HTTPS 是安全的")]),v._v(" "),_("li",[_("code",[v._v("HTTP")]),v._v(" 标准端口是80 ，而 HTTPS 的标准端口是443")]),v._v(" "),_("li",[_("code",[v._v("在OSI")]),v._v(" 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层")]),v._v(" "),_("li",[_("code",[v._v("HTTP")]),v._v(" 无法加密，而HTTPS 对传输的数据进行加密")]),v._v(" "),_("li",[_("code",[v._v("HTTP无需证书，而HTTPS")]),v._v(" 需要CA机构wosign的颁发的SSL证书")])]),v._v(" "),_("h2",{attrs:{id:"get-和-post-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[v._v("#")]),v._v(" GET 和 POST 的区别")]),v._v(" "),_("p",[v._v("从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。\n之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。\n受浏览器的影响，在实际开发中，GET 和 POST 有以下区别：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("浏览器在发送 GET 请求时，不会附带请求体")])]),v._v(" "),_("li",[_("p",[v._v("GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。")])]),v._v(" "),_("li",[_("p",[v._v("GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制")])]),v._v(" "),_("li",[_("p",[v._v("大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中")])]),v._v(" "),_("li",[_("p",[v._v("刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。")])]),v._v(" "),_("li",[_("p",[v._v("GET 请求的地址可以被保存为浏览器书签，POST 不可以")])])]),v._v(" "),_("h2",{attrs:{id:"浏览器渲染机制、重绘、重排"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制、重绘、重排"}},[v._v("#")]),v._v(" 浏览器渲染机制、重绘、重排")]),v._v(" "),_("p",[v._v("网页生成过程：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("HTML")]),v._v("被HTML解析器解析成"),_("code",[v._v("DOM")]),v._v(" 树")]),v._v(" "),_("li",[_("code",[v._v("css")]),v._v("则被css解析器解析成"),_("code",[v._v("CSSOM")]),v._v(" 树")]),v._v(" "),_("li",[v._v("结合"),_("code",[v._v("DOM")]),v._v("树和"),_("code",[v._v("CSSOM")]),v._v("树，生成一棵渲染树("),_("code",[v._v("Render Tree")]),v._v(")")]),v._v(" "),_("li",[v._v("生成布局（"),_("code",[v._v("flow")]),v._v("），即将所有渲染树的所有节点进行平面合成")]),v._v(" "),_("li",[v._v("将布局绘制（"),_("code",[v._v("paint")]),v._v("）在屏幕上")])]),v._v(" "),_("p",[_("a",[v._v("重排(也称回流):")]),v._v("  当DOM的变化影响了元素的几何属性（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中正确的位置，这个过程就叫回流。触发：")]),v._v(" "),_("ol",[_("li",[v._v("添加或者删除可见的DOM元素")]),v._v(" "),_("li",[v._v("元素尺寸改变——边距、填充、边框、宽度和高度")])]),v._v(" "),_("p",[_("a",[v._v("重绘：")]),v._v(" 当一个元素的外观发生了改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘，触发：")]),v._v(" "),_("ul",[_("li",[v._v("改变元素的color、background、box-shadow属性")])]),v._v(" "),_("h2",{attrs:{id:"url按下回车之后发生了什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#url按下回车之后发生了什么"}},[v._v("#")]),v._v(" url按下回车之后发生了什么")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("1 解析域名\n2 缓存判断   --有资源直接返回、否则向服务器发起新的请求\n3 DNS解析\n4 获取MAC地址\n5 会把请求的内容存储到dns\n6 TCP三次握手\n7 HTTPS握手\n8 返回数据\n9 TCP四次挥手\n")])])]),_("h2",{attrs:{id:"cookie、sessionstorage、localstorage的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie、sessionstorage、localstorage的区别"}},[v._v("#")]),v._v(" cookie、sessionStorage、localStorage的区别")]),v._v(" "),_("ul",[_("li",[v._v("cookie 可以设置失效时间")]),v._v(" "),_("li",[v._v("localStorage 除非手动清除，否则永久保存")]),v._v(" "),_("li",[v._v("sessionStorage 尽在当前网页有效，关闭页面就被清除")]),v._v(" "),_("li",[v._v("cookie储存大小是4k，localStorage和sessionStorage是5M")]),v._v(" "),_("li",[v._v("请求时：cookie自动携带HTTP头部中，localStorage和sessionStorage仅在浏览器保存，不参与服务器通信")]),v._v(" "),_("li",[v._v("cookie是由服务器写入的，而sessionStorage、localStorage是由前端写入的")]),v._v(" "),_("li",[v._v("cookie用于储存登录信息，localStorage常用于不易变动的数据，sessionStorage常用于检查用户是否是刷新进入页面、如回复播放器进度条的功能")])]),v._v(" "),_("h2",{attrs:{id:"promise-all和promise-race的区别的使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#promise-all和promise-race的区别的使用场景"}},[v._v("#")]),v._v(" Promise.all和Promise.race的区别的使用场景")]),v._v(" "),_("p",[_("a",[v._v("（1）Promise.all")]),v._v(" "),_("code",[v._v("Promise.all")]),v._v("可以将多个"),_("code",[v._v("Promise")]),v._v("实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是"),_("a",[v._v("一个结果数组")]),v._v("，而失败的时候则返回"),_("a",[v._v("最先被reject失败状态的值")])]),v._v(" "),_("p",[v._v("Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。")]),v._v(" "),_("p",[_("a",[v._v("（2）Promise.race")]),v._v("\n顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})\n")])])]),_("h2",{attrs:{id:"谈谈你对-tcp-三次握手和四次挥手的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对-tcp-三次握手和四次挥手的理解"}},[v._v("#")]),v._v(" 谈谈你对 TCP 三次握手和四次挥手的理解")]),v._v(" "),_("h1",{attrs:{id:"tcp-协议通过三次握手建立可靠的点对点连接-具体过程是"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议通过三次握手建立可靠的点对点连接-具体过程是"}},[v._v("#")]),v._v(" TCP 协议通过三次握手建立可靠的点对点连接，具体过程是：")]),v._v(" "),_("p",[v._v("首先服务器进入监听状态，然后即可处理连接")]),v._v(" "),_("p",[v._v("1.第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。")]),v._v(" "),_("p",[v._v("2.第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。")]),v._v(" "),_("p",[v._v("3.第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。")]),v._v(" "),_("p",[v._v("最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成")]),v._v(" "),_("h1",{attrs:{id:"当需要关闭连接时-需要进行四次挥手才能关闭"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当需要关闭连接时-需要进行四次挥手才能关闭"}},[v._v("#")]),v._v(" 当需要关闭连接时，需要进行四次挥手才能关闭")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。")])]),v._v(" "),_("li",[_("p",[v._v("Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。")])]),v._v(" "),_("li",[_("p",[v._v("Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。")])]),v._v(" "),_("li",[_("p",[v._v("Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。")])]),v._v(" "),_("li",[_("p",[v._v("Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。")])]),v._v(" "),_("li",[_("p",[v._v("Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。")])])]),v._v(" "),_("h1",{attrs:{id:"简单的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单的理解"}},[v._v("#")]),v._v(" 简单的理解")]),v._v(" "),_("p",[_("a",[v._v("三次握手")])]),v._v(" "),_("ol",[_("li",[v._v("客户端向服务端发信息：你能接收到我的信息吗")]),v._v(" "),_("li",[v._v("服务端回复客户端信息：我能收到你的信息，你能收到我的回复信息吗")]),v._v(" "),_("li",[v._v("客户信息向服务端回复：收到你的信息了，那我开始向你传输数据了")])]),v._v(" "),_("p",[_("a",[v._v("四次挥手")])]),v._v(" "),_("ol",[_("li",[v._v("客户端告诉服务端：数据发送完了")]),v._v(" "),_("li",[v._v("服务端回复客户端：知道你发完了，我还没接受完等一下")]),v._v(" "),_("li",[v._v("服务端回复客户端：数据接收完了")]),v._v(" "),_("li",[v._v("客户端回复服务端：知道你接收完成")])])])}),[],!1,null,null,null);_.default=e.exports}}]);